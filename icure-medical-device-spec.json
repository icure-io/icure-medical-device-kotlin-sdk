{
  "openapi": "3.0.1",
  "info": {
    "title": "ICure Medical Device Micro Service",
    "description": "ICure Medical Device Micro Service",
    "version": "v2"
  },
  "servers": [
    {
      "url": "http://localhost:8912",
      "description": "Generated server url"
    }
  ],
  "paths": {
    "/rest/v2/user": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get the details of the logged User.",
        "description": "When you make a call to the server, an authentication token is used to identify you. This call returns the complete User object that corresponds to your authentication credentials.",
        "operationId": "getLoggedUser",
        "responses": {
          "200": {
            "description": "Returns the logged user in the body",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "User"
        ],
        "summary": "Create a new user or modify an existing one.",
        "description": "A user must have a login, an email or a mobilePhone defined, a user should be linked to either a Healthcare Professional, a Patient or a Device. When modifying an user, you must ensure that the rev obtained when getting or creating the user is present as the rev is used to guarantee that the user has not been modified by a third party.",
        "operationId": "createOrModifyUser",
        "requestBody": {
          "description": "The user that must be created in the database.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified user as a User object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "400": {
            "description": "if there is no login,email or mobilePhone in the provided User",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/patient": {
      "put": {
        "tags": [
          "Patient"
        ],
        "summary": "Create or update a [Patient]",
        "description": "When modifying a patient, you must ensure that the rev obtained when getting or creating the patient is present as the rev is used to guarantee that the patient has not been modified by a third party.",
        "operationId": "createOrModifyPatient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Patient"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Patient"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified patient as a [Patient] object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Patient"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Patient"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/medical/device/batch": {
      "put": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Create or update a batch of [MedicalDevice]",
        "description": "When modifying a device, you must ensure that the rev obtained when getting or creating the device is present as the rev is used to guarantee that the device has not been modified by a third party.",
        "operationId": "createOrModifyMedicalDevices",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified devices as a list of [MedicalDevice] objects, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MedicalDevice"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MedicalDevice"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Delete a batch of [MedicalDevice]",
        "description": "Deletes the batch of medical device identified by the provided [medicalDeviceIds].",
        "operationId": "deleteMedicalDevices",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "if there is no medical device with the provided [medicalDeviceIds].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/medical/device": {
      "put": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Create or update a [MedicalDevice]",
        "description": "When modifying a device, you must ensure that the rev obtained when getting or creating the device is present as the rev is used to guarantee that the device has not been modified by a third party.",
        "operationId": "createOrModifyMedicalDevice",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MedicalDevice"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/MedicalDevice"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified device as a [MedicalDevice] object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/healthcareprofessional": {
      "put": {
        "tags": [
          "HealthcareProfessional"
        ],
        "summary": "Create a new healthcare professional or modify an existing one.",
        "description": "When modifying an healthcare professional, you must ensure that the rev obtained when getting or creating the healthcare professional is present as the rev is used to guarantee that the healthcare professional has not been modified by a third party.",
        "operationId": "createOrModifyHealthcareProfessional",
        "requestBody": {
          "description": "The healthcare professional that must be created in the database.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HealthcareProfessional"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/HealthcareProfessional"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified healthcare professional as a Healthcare professional object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareProfessional"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareProfessional"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/{patientId}": {
      "put": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Create a [HealthcareElement]",
        "description": "When modifying an healthcare element, you must ensure that the rev obtained when getting or creating the healthcare element is present as the rev is used to guarantee that the healthcare element has not been modified by a third party.",
        "operationId": "createOrModifyHealthcareElement",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The healthcare element that must be created in the database.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/HealthcareElement"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/HealthcareElement"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified healthcare element as a [HealthcareElement] object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/batch/{patientId}": {
      "put": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Create a batch of [HealthcareElement]",
        "description": "When modifying an healthcare element, you must ensure that the rev obtained when getting or creating the healthcare element is present as the rev is used to guarantee that the healthcare element has not been modified by a third party.",
        "operationId": "createOrModifyHealthcareElements",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The healthcare element that must be created in the database.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified healthcare element as a [HealthcareElement] object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/HealthcareElement"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/HealthcareElement"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/{dataSampleId}/attachment": {
      "put": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Add or update the attachment of a DataSample",
        "description": "Link an attachment or update the attachment of a data sample",
        "operationId": "setDataSampleAttachment",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentName",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentVersion",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentExternalUuid",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentLanguage",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            },
            "application/xml": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified attachment as a [Document] object, with updated information",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          },
          "400": {
            "description": "if there is no data sample corresponding to the provided [dataSampleId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/for/{patientId}": {
      "put": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Create or update a [DataSample] for a patient",
        "description": "When modifying a data sample, you can't update the patient of it : For this, you need to delete the faulty data sample and create a new one. When modifying the data sample, you also need to keep the same batchId : It is not possible to change the batch of a data sample.",
        "operationId": "createOrModifyDataSampleFor",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSample"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/DataSample"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified data sample as a [DataSample] object, with updated information.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          },
          "400": {
            "description": "May happen in one of the following cases : \n                    - You provided a patientId that does not correspond to any existing [Patient];\n                    - You provided a batchId that does not correspond to any existing batch; \n                    - You provided a batchId that does not correspond to the batch of the updated data sample;\n                    ",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/batch/for/{patientId}": {
      "put": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Create or update a batch of [DataSample] for a patient",
        "description": "All the provided data samples will be created in the same batch. If you are trying to update some data samples, then those ones need to come from the same batch. \n                When modifying a data sample, you can't update the patient of it : For this, you need to delete the faulty data sample and create a new one. When modifying the data sample, you also need to keep the same batchId : It is not possible to change the batch of a data sample.\n                ",
        "operationId": "createOrModifyDataSamplesFor",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified data sample as a [DataSample] object, with updated information.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DataSample"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DataSample"
                  }
                }
              }
            }
          },
          "400": {
            "description": "May happen in one of the following cases : \n                    - You provided a patientId that does not correspond to any existing [Patient];\n                    - You provided a batchId that does not correspond to any existing batch; \n                    - You provided a batchId that does not correspond to the batch of the updated data sample;\n                    - You provided data samples coming from different batches : If you want to add new data samples in an existing batch, do not forget to refer the batch id for the new ones as well;\n                    - You tried to create / update more than 1000 data samples (including the ones contained in compound values) : iCure can't process more than 1000 data samples by batch;   \n                    ",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DataSample"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/coding/batch": {
      "put": {
        "tags": [
          "Coding"
        ],
        "summary": "Create or update a batch of [Coding]",
        "description": "When modifying codings, you must ensure that the rev obtained when getting or creating the coding is present as the rev is used to guarantee that the coding has not been modified by a third party.",
        "operationId": "createOrModifyCodings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified codings as a [Coding] objects, with updated revs.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Coding"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Coding"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/coding": {
      "put": {
        "tags": [
          "Coding"
        ],
        "summary": "Create or update a [Coding]",
        "description": "When modifying a coding, you must ensure that the rev obtained when getting or creating the coding is present as the rev is used to guarantee that the coding has not been modified by a third party.",
        "operationId": "createOrModifyCoding",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Coding"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Coding"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the created or modified coding as a [Coding] object, with an updated rev.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/user/token/{userId}": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Check token validity for a user.",
        "description": "Checks that the provided token is (still) valid for the provided user id (or user login).",
        "operationId": "checkTokenValidity",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "The UUID that identifies the user uniquely",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "token",
            "in": "header",
            "description": "The token that will be checked",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a boolean (true/false). True if the token is valid, False otherwise",
            "content": {
              "*/*": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "if there is no user with the provided userId.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Create a token for a user.",
        "description": "A token is used to authenticate the user. It is just like a password but it is destined to be used by programs instead of humans. Tokens have a limited validity period (one month).",
        "operationId": "createToken",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "The UUID that identifies the user uniquely",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the token that can be subsequently used to authenticate the user with id userId.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no user with the provided userId.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/user/match": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Load user ids from the database by filtering them using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Users are AllUsersFilter and UsersByIdsFilter. This method returns the list of the ids of the users matching the filter.",
        "operationId": "matchUsers",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all user ids matching the filter.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/user/filter": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Load users from the database by filtering them using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Users are AllUsersFilter and UsersByIdsFilter. This method returns a paginated list of users (with a cursor that lets you query the following items).",
        "operationId": "filterUsers",
        "parameters": [
          {
            "name": "nextUserId",
            "in": "query",
            "description": "The id of the first User in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of users to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of Users.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListUser"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListUser"
                }
              }
            }
          },
          "400": {
            "description": "if there is no user with the provided userId.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListUser"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/patient/match": {
      "post": {
        "tags": [
          "Patient"
        ],
        "summary": "Load patient ids from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [Patient] are AllPatientsFilter and PatientsByIdsFilter. This method returns the list of the ids of the users matching the [filter].",
        "operationId": "matchPatients",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all [Patient] ids matching the [filter].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/patient/filter": {
      "post": {
        "tags": [
          "Patient"
        ],
        "summary": "Load patients from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [Patient] are AllPatientsFilter and PatientsByIdsFilter. This method returns a paginated list of patient (with a cursor that lets you query the following items).",
        "operationId": "filterPatients",
        "parameters": [
          {
            "name": "nextPatientId",
            "in": "query",
            "description": "The id of the first patient in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of patients to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of [Patient].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListPatient"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListPatient"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/medical/device/match": {
      "post": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Load medical device ids from the database by filtering them using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [MedicalDevice] are AllDevicesFilter and DevicesByIdsFilter. This method returns the list of the ids of the users matching the filter.",
        "operationId": "matchMedicalDevices",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all medical device ids matching the [filter].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/medical/device/filter": {
      "post": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Load devices from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [MedicalDevice] are AllDevicesFilter and DevicesByIdsFilter. This method returns a paginated list of medical devices (with a cursor that lets you query the following items).",
        "operationId": "filterMedicalDevices",
        "parameters": [
          {
            "name": "nextDeviceId",
            "in": "query",
            "description": "The id of the first device in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of devices to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of [MedicalDevice].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListMedicalDevice"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListMedicalDevice"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/healthcareprofessional/match": {
      "post": {
        "tags": [
          "HealthcareProfessional"
        ],
        "summary": "Load healthcare professional ids from the database by filtering them using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Healthcare professionals are AllHealthcare professionalsFilter and Healthcare professionalsByIdsFilter. This method returns the list of the ids of the healthcare professionals matching the filter.",
        "operationId": "matchHealthcareProfessionalBy",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all healthcare professional ids matching the filter.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/healthcareprofessional/filter": {
      "post": {
        "tags": [
          "HealthcareProfessional"
        ],
        "summary": "Load healthcare professionals from the database by filtering them using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Healthcare professionals are AllHealthcareProfessionalsFilter and HealthcarProfessionalsByIdsFilter. This method returns a paginated list of healthcare professionals (with a cursor that lets you query the following items).",
        "operationId": "filterHealthcareProfessionalBy",
        "parameters": [
          {
            "name": "nextHcpId",
            "in": "query",
            "description": "The id of the first Healthcare professional in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of healthcare professionals to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of Healthcare professionals.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListHealthcareProfessional"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListHealthcareProfessional"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/match": {
      "post": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Load healthcare elements ids from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Healthcare element are AllHealthcareElementsFilter and HealthcareElementsByIdsFilter. This method returns a paginated list of healthcare element (with a cursor that lets you query the following items).",
        "operationId": "matchHealthcareElement",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all healthcare elements ids matching the filter.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/filter": {
      "post": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Load healthcare elements from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for Healthcare element are AllHealthcareElementsFilter and HealthcareElementsByIdsFilter. This method returns a paginated list of healthcare element (with a cursor that lets you query the following items).",
        "operationId": "filterHealthcareElement",
        "parameters": [
          {
            "name": "nextHealthElementId",
            "in": "query",
            "description": "The id of the first [HealthcareElement] in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of healthcare elements to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of Healthcare elements.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListHealthcareElement"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListHealthcareElement"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/match": {
      "post": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Find data samples ids using the provided Filter.",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [DataSample] are AllDataSamplesFilter and DataSamplesByIdsFilter. This method returns a paginated list of data samples (with a cursor that lets you query the following items).",
        "operationId": "matchDataSample",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all data sample ids matching the filter.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/filter": {
      "post": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Find data samples using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [DataSample] are AllDataSamplesFilter and DataSamplesByIdsFilter. This method returns a paginated list of data samples (with a cursor that lets you query the following items).",
        "operationId": "filterDataSample",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of [DataSample].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListDataSample"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListDataSample"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/batch": {
      "post": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Delete a batch of [Data Samples]",
        "description": "Deletes the batch of data samples identified by the provided [dataSampleIds]. The data samples to delete need to be part of the same batch",
        "operationId": "deleteDataSamples",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns the ids of deleted objects",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "if you tried to delete data samples from different batches",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/coding/match": {
      "post": {
        "tags": [
          "Coding"
        ],
        "summary": "Load coding ids from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [Coding] are AllCodingsFilter and CodingsByIdsFilter. This method returns a paginated list of coding (with a cursor that lets you query the following items).",
        "operationId": "matchCoding",
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a list of all [Coding] ids matching the [filter].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/coding/filter": {
      "post": {
        "tags": [
          "Coding"
        ],
        "summary": "Load codings from the database by filtering them using the provided [filter].",
        "description": "Filters are complex selectors that are built by combining basic building blocks. Examples of filters available for [Coding] are AllCodingsFilter and CodingsByIdsFilter. This method returns a paginated list of coding (with a cursor that lets you query the following items).",
        "operationId": "filterCoding",
        "parameters": [
          {
            "name": "nextCodingId",
            "in": "query",
            "description": "The id of the first coding in the next page",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of codings to return in the queried page",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "requestBody": {
          "description": "The Filter object that describes which condition(s) the elements whose the ids should be returned must fulfill",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Filter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns a PaginatedList of [Coding].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListCoding"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedListCoding"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/user/{userId}": {
      "get": {
        "tags": [
          "User"
        ],
        "summary": "Get a User by id.",
        "description": "Each user is uniquely identified by a user id. The user id is a UUID. This userId is the preferred method to retrieve one specific user.",
        "operationId": "getUser",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "The UUID that identifies the user uniquely",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched user as a User object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "400": {
            "description": "if there is no user with the provided userId.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Delete an existing user.",
        "description": "Deletes the user identified by the provided unique userId.",
        "operationId": "deleteUser",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "The UUID that uniquely identifies the user to be deleted.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no user with the provided userId.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/patient/{patientId}": {
      "get": {
        "tags": [
          "Patient"
        ],
        "summary": "Get a [Patient]",
        "description": "Each patient is uniquely identified by a patient id. The patient id is a UUID. This [patientId] is the preferred method to retrieve one specific patient.",
        "operationId": "getPatient",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched patient as a [Patient] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Patient"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Patient"
                }
              }
            }
          },
          "400": {
            "description": "if there is no patient with the provided [patientId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Patient"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Patient"
        ],
        "summary": "Delete a [Patient]",
        "description": "Deletes the patient identified by the provided unique [patientId].",
        "operationId": "deletePatient",
        "parameters": [
          {
            "name": "patientId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no patient with the provided [patientId].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/medical/device/{medicalDeviceId}": {
      "get": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Get a Medical Device",
        "description": "Each medical device is uniquely identified by a device id. The device id is a UUID. This [medicalDeviceId] is the preferred method to retrieve one specific device.",
        "operationId": "getMedicalDevice",
        "parameters": [
          {
            "name": "medicalDeviceId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched device as a [MedicalDevice] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          },
          "400": {
            "description": "if there is no device with the provided [medicalDeviceId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalDevice"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "MedicalDevice"
        ],
        "summary": "Delete a [MedicalDevice]",
        "description": "Deletes the medical device identified by the provided unique [medicalDeviceId].",
        "operationId": "deleteMedicalDevice",
        "parameters": [
          {
            "name": "medicalDeviceId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no medical device with the provided [medicalDeviceId].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/healthcareprofessional/{hcpId}": {
      "get": {
        "tags": [
          "HealthcareProfessional"
        ],
        "summary": "Get a Healthcare professional by id.",
        "description": "Each healthcare professional is uniquely identified by a healthcare professional id. The healthcare professional id is a UUID. This hcpId is the preferred method to retrieve one specific healthcare professional.",
        "operationId": "getHealthcareProfessional",
        "parameters": [
          {
            "name": "hcpId",
            "in": "path",
            "description": "The UUID that identifies the healthcare professional uniquely",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched healthcare professional as a Healthcare professional object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareProfessional"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareProfessional"
                }
              }
            }
          },
          "400": {
            "description": "if there is no healthcare professional with the provided hcpId.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareProfessional"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "HealthcareProfessional"
        ],
        "summary": "Delete an existing healthcare professional.",
        "description": "Deletes the healthcare professional identified by the provided unique hcpId.",
        "operationId": "deleteHealthcareProfessional",
        "parameters": [
          {
            "name": "hcpId",
            "in": "path",
            "description": "The UUID that uniquely identifies the healthcare professional to be deleted.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no healthcare professional with the provided hcpId.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/{healthcareElementId}": {
      "get": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Get a [HealthcareElement]",
        "description": "Each [HealthcareElement] is uniquely identified by a healthcare element id. The healthcare element id is a UUID. This [healthcareElementId] is the preferred method to retrieve one specific healthcare element.",
        "operationId": "getHealthcareElement",
        "parameters": [
          {
            "name": "healthcareElementId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched healthcare element as a [HealthcareElement] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          },
          "400": {
            "description": "if there is no healthcare element with the provided [healthcareElementId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/HealthcareElement"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/{dataSampleId}/attachment/{documentId}/{attachmentId}": {
      "get": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Get attachment content of a DataSample",
        "description": "Data Samples may contain attachments such as prescriptions, reports, ... Use this method to get the content of an attachment",
        "operationId": "getDataSampleAttachmentContent",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "attachmentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched metadata as a flow of [DataBuffer]",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "short": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "char": {
                        "type": "string"
                      },
                      "int": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "long": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "float": {
                        "type": "number",
                        "format": "float"
                      },
                      "double": {
                        "type": "number",
                        "format": "double"
                      },
                      "direct": {
                        "type": "boolean"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "if there is no data sample or no attachment corresponding to the provided [dataSampleId], [documentId] and [attachmentId].",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "short": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "char": {
                        "type": "string"
                      },
                      "int": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "long": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "float": {
                        "type": "number",
                        "format": "float"
                      },
                      "double": {
                        "type": "number",
                        "format": "double"
                      },
                      "direct": {
                        "type": "boolean"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/{dataSampleId}/attachment/{documentId}": {
      "get": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Get document metadata of a DataSample attachment",
        "description": "Data Samples may contain attachments such as prescriptions, reports, ... Use this method to get the document metadata information of an attachment",
        "operationId": "getDataSampleAttachmentDocument",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched metadata as a [Document] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          },
          "400": {
            "description": "if there is no data sample or no attachment corresponding to the provided [dataSampleId] and [attachmentId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Delete an attachment of a DataSample",
        "description": "Deletes an attachment, using its corresponding documentId",
        "operationId": "deleteAttachment",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the id of the deleted attachment",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/data/sample/{dataSampleId}": {
      "get": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Get a [DataSample] by its id",
        "description": "Each data sample is uniquely identified by a data sample id which is a UUID. This [dataSampleId] is the preferred method to retrieve one specific data sample.",
        "operationId": "getDataSample",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched data sample as a [DataSample] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          },
          "400": {
            "description": "if there is no data sample corresponding to the provided [dataSampleId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/DataSample"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Data Sample"
        ],
        "summary": "Delete a [DataSample] by its id",
        "description": "Deletes the data sample identified by the provided unique [dataSampleId].",
        "operationId": "deleteDataSample",
        "parameters": [
          {
            "name": "dataSampleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the id of the deleted data sample.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing or (by providing an invalid) authentication token (BASIC, SesssionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/coding/{codingId}": {
      "get": {
        "tags": [
          "Coding"
        ],
        "summary": "Get a [Coding]",
        "description": "Each coding is uniquely identified by a coding id. The coding id is a UUID. This [codingId] is the preferred method to retrieve one specific coding.",
        "operationId": "getCoding",
        "parameters": [
          {
            "name": "codingId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the fetched coding as a [Coding] object",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          },
          "400": {
            "description": "if there is no coding with the provided [codingId].",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/Coding"
                }
              }
            }
          }
        }
      }
    },
    "/rest/v2/hce/{healthElementId}": {
      "delete": {
        "tags": [
          "Healthcare Element"
        ],
        "summary": "Delete a Healthcare Element",
        "description": "Deletes the healthcare element identified by the provided unique [healthElementId].",
        "operationId": "deleteHealthcareElement",
        "parameters": [
          {
            "name": "healthElementId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rev of the deleted object.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "403": {
            "description": "if you make this call without providing an authentication token (BASIC, SessionId).",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "if there is no healthcare element with the provided [healthElementId].",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AuthenticationToken": {
        "required": [
          "creationTime",
          "token",
          "validity"
        ],
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Encrypted token"
          },
          "creationTime": {
            "type": "integer",
            "description": "Validity starting time of the token",
            "format": "int64"
          },
          "validity": {
            "type": "integer",
            "description": "Token validity in seconds",
            "format": "int64"
          }
        },
        "description": "Encrypted and time-limited Authentication tokens used for inter-applications authentication"
      },
      "Property": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/PropertyType"
          },
          "typedValue": {
            "$ref": "#/components/schemas/TypedValueObject"
          },
          "deleted": {
            "type": "integer",
            "format": "int64"
          }
        },
        "description": "Extra properties for the user. Those properties are typed (see class Property)"
      },
      "PropertyType": {
        "type": "object",
        "properties": {
          "identifier": {
            "type": "string"
          },
          "type": {
            "type": "string",
            "enum": [
              "BOOLEAN",
              "INTEGER",
              "DOUBLE",
              "STRING",
              "DATE",
              "CLOB",
              "JSON"
            ]
          }
        }
      },
      "TypedValueObject": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "BOOLEAN",
              "INTEGER",
              "DOUBLE",
              "STRING",
              "DATE",
              "CLOB",
              "JSON"
            ]
          },
          "booleanValue": {
            "type": "boolean"
          },
          "integerValue": {
            "type": "integer",
            "format": "int32"
          },
          "doubleValue": {
            "type": "number",
            "format": "double"
          },
          "stringValue": {
            "type": "string"
          },
          "dateValue": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "User": {
        "required": [
          "authenticationTokens",
          "autoDelegations",
          "properties",
          "roles"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "the Id of the user. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "the revision of the user in the database, used for conflict management / optimistic locking."
          },
          "deletionDate": {
            "type": "integer",
            "description": "the soft delete timestamp. When a user is deleted, this is set to a non null value: the moment of the deletion",
            "format": "int64"
          },
          "created": {
            "type": "integer",
            "description": "the creation date of the user (encoded as epoch).",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "Last name of the user. This is the official last name that should be used for official administrative purposes."
          },
          "properties": {
            "uniqueItems": true,
            "type": "array",
            "description": "Extra properties for the user. Those properties are typed (see class Property)",
            "items": {
              "$ref": "#/components/schemas/Property"
            }
          },
          "roles": {
            "uniqueItems": true,
            "type": "array",
            "description": "Roles assigned to this user",
            "items": {
              "type": "string",
              "description": "Roles assigned to this user"
            }
          },
          "login": {
            "type": "string",
            "description": "Username for this user. We encourage using an email address"
          },
          "passwordHash": {
            "type": "string",
            "description": "Hashed version of the password (BCrypt is used for hashing)"
          },
          "secret": {
            "type": "string",
            "description": "Secret token used to verify 2fa"
          },
          "use2fa": {
            "type": "boolean",
            "description": "Whether the user has activated two factors authentication"
          },
          "groupId": {
            "type": "string",
            "description": "id of the group (practice/hospital) the user is member of"
          },
          "healthcarePartyId": {
            "type": "string",
            "description": "Id of the healthcare party if the user is a healthcare party."
          },
          "patientId": {
            "type": "string",
            "description": "Id of the patient if the user is a patient"
          },
          "deviceId": {
            "type": "string",
            "description": "Id of the patient if the user is a patient"
          },
          "autoDelegations": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "description": "Delegations that are automatically generated client side when a new database object is created by this user",
              "items": {
                "type": "string",
                "description": "Delegations that are automatically generated client side when a new database object is created by this user"
              }
            },
            "description": "Delegations that are automatically generated client side when a new database object is created by this user"
          },
          "email": {
            "type": "string",
            "description": "email address of the user (used for token exchange or password recovery)."
          },
          "mobilePhone": {
            "type": "string",
            "description": "mobile phone of the user (used for token exchange or password recovery)."
          },
          "authenticationTokens": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/AuthenticationToken"
            },
            "description": "Encrypted and time-limited Authentication tokens used for inter-applications authentication"
          }
        }
      },
      "Address": {
        "required": [
          "telecoms"
        ],
        "type": "object",
        "properties": {
          "addressType": {
            "type": "string",
            "enum": [
              "home",
              "work",
              "vacation",
              "hospital",
              "clinic",
              "hq",
              "other",
              "temporary",
              "postal",
              "diplomatic",
              "reference"
            ]
          },
          "description": {
            "type": "string"
          },
          "street": {
            "type": "string"
          },
          "houseNumber": {
            "type": "string"
          },
          "postboxNumber": {
            "type": "string"
          },
          "postalCode": {
            "type": "string"
          },
          "city": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "country": {
            "type": "string"
          },
          "note": {
            "type": "string"
          },
          "telecoms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Telecom"
            }
          }
        },
        "description": "the list of addresses (with address type)."
      },
      "CodingReference": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "code": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "description": "Codified list of professions exercised by this patient."
      },
      "Delegation": {
        "required": [
          "tags"
        ],
        "type": "object",
        "properties": {
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "owner": {
            "type": "string"
          },
          "delegatedTo": {
            "type": "string"
          },
          "key": {
            "type": "string"
          }
        }
      },
      "Identifier": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "assigner": {
            "type": "string"
          },
          "start": {
            "type": "string"
          },
          "end": {
            "type": "string"
          },
          "system": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/CodingReference"
          },
          "use": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "description": "Typically used for business / client identifiers. An identifier should identify a patient uniquely and unambiguously. However, iCure can't guarantee the uniqueness of those identifiers : This is something you need to take care of."
      },
      "Partnership": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "primary_contact",
              "primary_contact_for",
              "family",
              "friend",
              "counselor",
              "contact",
              "brother",
              "brotherinlaw",
              "child",
              "daughter",
              "employer",
              "father",
              "grandchild",
              "grandparent",
              "husband",
              "lawyer",
              "mother",
              "neighbour",
              "notary",
              "partner",
              "sister",
              "sisterinlaw",
              "son",
              "spouse",
              "stepdaughter",
              "stepfather",
              "stepmother",
              "stepson",
              "tutor",
              "next_of_kin",
              "federal_agency",
              "insurance_company",
              "state_agency",
              "unknown",
              "seealso",
              "refer"
            ]
          },
          "status": {
            "type": "string",
            "enum": [
              "active",
              "complicated",
              "past"
            ]
          },
          "partnerId": {
            "type": "string"
          }
        },
        "description": "List of partners, or persons of contact (of class Partnership, see below)."
      },
      "Patient": {
        "required": [
          "active",
          "addresses",
          "codes",
          "deactivationReason",
          "identifiers",
          "labels",
          "languages",
          "mergedIds",
          "names",
          "parameters",
          "partnerships",
          "patientHealthCareParties",
          "patientProfessions",
          "properties"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "the Id of the patient. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "the revision of the patient in the database, used for conflict management / optimistic locking."
          },
          "identifiers": {
            "type": "array",
            "description": "Typically used for business / client identifiers. An identifier should identify a patient uniquely and unambiguously. However, iCure can't guarantee the uniqueness of those identifiers : This is something you need to take care of.",
            "items": {
              "$ref": "#/components/schemas/Identifier"
            }
          },
          "created": {
            "type": "integer",
            "description": "the creation date of the patient (encoded as epoch).",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "description": "the last modification date of the patient (encoded as epoch).",
            "format": "int64"
          },
          "author": {
            "type": "string",
            "description": "The id of the [User] that created this patient. When creating the patient, this field will be filled automatically by the current user id if not provided."
          },
          "responsible": {
            "type": "string",
            "description": "The id of the data owner that is responsible of this patient. When creating the patient, will be filled automatically by the current user data owner id ([HealthcareProfessional], [Patient] or [MedicalDevice]) if missing"
          },
          "labels": {
            "uniqueItems": true,
            "type": "array",
            "description": "A label is an item from a codification system that qualifies a patient as being member of a certain class, whatever the value it might have taken. If the label qualifies the content of a field, it means that whatever the content of the field, the label will always apply. LOINC is a codification system typically used for labels.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "codes": {
            "uniqueItems": true,
            "type": "array",
            "description": "A code is an item from a codification system that qualifies the content of this patient.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "endOfLife": {
            "type": "integer",
            "description": "Soft delete (unix epoch in ms) timestamp of the patient",
            "format": "int64"
          },
          "deletionDate": {
            "type": "integer",
            "description": "the soft delete timestamp. When a patient is deleted, this is set to a non null value: the moment of the deletion",
            "format": "int64"
          },
          "firstName": {
            "type": "string",
            "description": "the firstname (name) of the patient."
          },
          "lastName": {
            "type": "string",
            "description": "the lastname (surname) of the patient. This is the official lastname that should be used for official administrative purposes."
          },
          "names": {
            "type": "array",
            "description": "the list of all names of the patient, also containing the official full name information. Ordered by preference of use. First element is therefore the official name used for the patient in the application",
            "items": {
              "$ref": "#/components/schemas/PersonName"
            }
          },
          "companyName": {
            "type": "string",
            "description": "the name of the company this patient is member of."
          },
          "languages": {
            "type": "array",
            "description": "the list of languages spoken by the patient ordered by fluency (alpha-2 code http://www.loc.gov/standards/iso639-2/ascii_8bits.html).",
            "items": {
              "type": "string",
              "description": "the list of languages spoken by the patient ordered by fluency (alpha-2 code http://www.loc.gov/standards/iso639-2/ascii_8bits.html)."
            }
          },
          "addresses": {
            "type": "array",
            "description": "the list of addresses (with address type).",
            "items": {
              "$ref": "#/components/schemas/Address"
            }
          },
          "civility": {
            "type": "string",
            "description": "Mr., Ms., Pr., Dr. ..."
          },
          "gender": {
            "type": "string",
            "description": "the gender of the patient: male, female, indeterminate, changed, changedToMale, changedToFemale, unknown",
            "enum": [
              "male",
              "female",
              "indeterminate",
              "changed",
              "changedToMale",
              "changedToFemale",
              "unknown"
            ]
          },
          "birthSex": {
            "type": "string",
            "description": "the birth sex of the patient: male, female, indeterminate, unknown",
            "enum": [
              "male",
              "female",
              "indeterminate",
              "changed",
              "changedToMale",
              "changedToFemale",
              "unknown"
            ]
          },
          "mergeToPatientId": {
            "type": "string",
            "description": "The id of the patient this patient has been merged with."
          },
          "mergedIds": {
            "uniqueItems": true,
            "type": "array",
            "description": "The ids of the patients that have been merged inside this patient.",
            "items": {
              "type": "string",
              "description": "The ids of the patients that have been merged inside this patient."
            }
          },
          "alias": {
            "type": "string",
            "description": "An alias of the person, nickname, ..."
          },
          "active": {
            "type": "boolean",
            "description": "Is the patient active (boolean).",
            "default": true
          },
          "deactivationReason": {
            "type": "string",
            "description": "When not active, the reason for deactivation.",
            "default": "DeactivationReason.none",
            "enum": [
              "deceased",
              "moved",
              "other_doctor",
              "retired",
              "no_contact",
              "unknown",
              "none"
            ]
          },
          "ssin": {
            "type": "string",
            "description": "Social security inscription number."
          },
          "maidenName": {
            "type": "string",
            "description": "Lastname at birth (can be different of the current name), depending on the country, must be used to design the patient ."
          },
          "spouseName": {
            "type": "string",
            "description": "Lastname of the spouse for a married woman, depending on the country, can be used to design the patient."
          },
          "partnerName": {
            "type": "string",
            "description": "Lastname of the partner, should not be used to design the patient."
          },
          "personalStatus": {
            "type": "string",
            "description": "any of `single`, `in_couple`, `married`, `separated`, `divorced`, `divorcing`, `widowed`, `widower`, `complicated`, `unknown`, `contract`, `other`.",
            "enum": [
              "single",
              "in_couple",
              "married",
              "separated",
              "divorced",
              "divorcing",
              "widowed",
              "widower",
              "complicated",
              "unknown",
              "contract",
              "other",
              "annulled",
              "polygamous"
            ]
          },
          "dateOfBirth": {
            "type": "integer",
            "description": "The birthdate encoded as a fuzzy date on 8 positions (YYYYMMDD) MM and/or DD can be set to 00 if unknown (19740000 is a valid date).",
            "format": "int32"
          },
          "dateOfDeath": {
            "type": "integer",
            "description": "The date of death encoded as a fuzzy date on 8 positions (YYYYMMDD) MM and/or DD can be set to 00 if unknown (19740000 is a valid date).",
            "format": "int32"
          },
          "placeOfBirth": {
            "type": "string",
            "description": "The place of birth."
          },
          "placeOfDeath": {
            "type": "string",
            "description": "The place of death."
          },
          "deceased": {
            "type": "boolean",
            "description": "Is the patient deceased."
          },
          "education": {
            "type": "string",
            "description": "The level of education (college degree, undergraduate, phd)."
          },
          "profession": {
            "type": "string",
            "description": "The current professional activity."
          },
          "note": {
            "type": "string",
            "description": "A text note (can be confidential, encrypted by default)."
          },
          "administrativeNote": {
            "type": "string",
            "description": "An administrative note, not confidential."
          },
          "nationality": {
            "type": "string",
            "description": "The nationality of the patient."
          },
          "race": {
            "type": "string",
            "description": "The race of the patient."
          },
          "ethnicity": {
            "type": "string",
            "description": "The ethnicity of the patient."
          },
          "picture": {
            "type": "string",
            "description": "A picture usually saved in JPEG format.",
            "format": "byte"
          },
          "externalId": {
            "type": "string",
            "description": "An external (from another source) id with no guarantee or requirement for unicity ."
          },
          "partnerships": {
            "type": "array",
            "description": "List of partners, or persons of contact (of class Partnership, see below).",
            "items": {
              "$ref": "#/components/schemas/Partnership"
            }
          },
          "patientHealthCareParties": {
            "type": "array",
            "description": "Links (usually for therapeutic reasons) between this patient and healthcare parties (of class PatientHealthcareParty).",
            "items": {
              "$ref": "#/components/schemas/PatientHealthCareParty"
            }
          },
          "patientProfessions": {
            "type": "array",
            "description": "Codified list of professions exercised by this patient.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "parameters": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "description": "Extra parameters",
              "items": {
                "type": "string",
                "description": "Extra parameters"
              }
            },
            "description": "Extra parameters"
          },
          "properties": {
            "uniqueItems": true,
            "type": "array",
            "description": "Extra properties",
            "items": {
              "$ref": "#/components/schemas/Property"
            }
          },
          "systemMetaData": {
            "$ref": "#/components/schemas/SystemMetaDataOwnerEncrypted"
          }
        }
      },
      "PatientHealthCareParty": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "doctor",
              "referral",
              "medicalhouse",
              "retirementhome",
              "hospital",
              "other",
              "referringphysician",
              "managingorganization"
            ]
          },
          "healthcarePartyId": {
            "type": "string"
          }
        },
        "description": "Links (usually for therapeutic reasons) between this patient and healthcare parties (of class PatientHealthcareParty)."
      },
      "PersonName": {
        "required": [
          "firstNames",
          "prefix",
          "suffix"
        ],
        "type": "object",
        "properties": {
          "lastName": {
            "type": "string"
          },
          "firstNames": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "start": {
            "type": "integer",
            "format": "int64"
          },
          "end": {
            "type": "integer",
            "format": "int64"
          },
          "prefix": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "suffix": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "text": {
            "type": "string"
          },
          "use": {
            "type": "string",
            "enum": [
              "usual",
              "official",
              "temp",
              "nickname",
              "anonymous",
              "maiden",
              "old",
              "other"
            ]
          }
        },
        "description": "the list of all names of the patient, also containing the official full name information. Ordered by preference of use. First element is therefore the official name used for the patient in the application"
      },
      "SystemMetaDataOwnerEncrypted": {
        "required": [
          "cryptedForeignKeys",
          "delegations",
          "encryptionKeys",
          "hcPartyKeys",
          "privateKeyShamirPartitions",
          "secretForeignKeys"
        ],
        "type": "object",
        "properties": {
          "hcPartyKeys": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "privateKeyShamirPartitions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "secretForeignKeys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "cryptedForeignKeys": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          },
          "delegations": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          },
          "encryptionKeys": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          }
        }
      },
      "Telecom": {
        "type": "object",
        "properties": {
          "telecomType": {
            "type": "string",
            "enum": [
              "mobile",
              "phone",
              "email",
              "fax",
              "skype",
              "im",
              "medibridge",
              "ehealthbox",
              "apicrypt",
              "web",
              "print",
              "disk",
              "other",
              "pager"
            ]
          },
          "telecomNumber": {
            "type": "string"
          },
          "telecomDescription": {
            "type": "string"
          }
        }
      },
      "MedicalDevice": {
        "required": [
          "codes",
          "identifiers",
          "labels",
          "properties"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the MedicalDevice. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "the revision of the medical device in the database, used for conflict management / optimistic locking."
          },
          "deletionDate": {
            "type": "integer",
            "description": "the soft delete timestamp. When a medical device is deleted, this is set to a non null value: the moment of the deletion",
            "format": "int64"
          },
          "identifiers": {
            "type": "array",
            "description": "Typically used for business / client identifiers. An identifier should identify a device uniquely and unambiguously. However, iCure can't guarantee the uniqueness of those identifiers : This is something you need to take care of.",
            "items": {
              "$ref": "#/components/schemas/Identifier"
            }
          },
          "created": {
            "type": "integer",
            "description": "the creation date of the medical device (encoded as epoch).",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "description": "the last modification date of the medical device (encoded as epoch).",
            "format": "int64"
          },
          "author": {
            "type": "string",
            "description": "The id of the [User] that created this medical device. When creating the device, this field will be filled automatically by the current user id if not provided."
          },
          "responsible": {
            "type": "string",
            "description": "The id of the data owner that is responsible of this medical device. When creating the medical device, will be filled automatically by the current user data owner id ([HealthcareProfessional], [Patient] or [MedicalDevice]) if missing"
          },
          "labels": {
            "uniqueItems": true,
            "type": "array",
            "description": "A label is an item from a codification system that qualifies a medical device as being member of a certain class, whatever the value it might have taken. If the label qualifies the content of a field, it means that whatever the content of the field, the label will always apply. LOINC is a codification system typically used for labels.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "codes": {
            "uniqueItems": true,
            "type": "array",
            "description": "A code is an item from a codification system that qualifies the content of this medical device. SNOMED-CT, ICPC-2 or ICD-10 codifications systems can be used for codes",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "endOfLife": {
            "type": "integer",
            "description": "Soft delete (unix epoch in ms) timestamp of the medical device",
            "format": "int64"
          },
          "externalId": {
            "type": "string",
            "description": "An external (from another source) id with no guarantee or requirement for unicity."
          },
          "name": {
            "type": "string",
            "description": "Name of the device/application recording the data"
          },
          "type": {
            "type": "string",
            "description": "Type of device/application recording the data. (eg. \"smartphone\", \"watch\",...)"
          },
          "brand": {
            "type": "string",
            "description": "Brand of the device recording the data"
          },
          "model": {
            "type": "string",
            "description": "Model of the device recording the data"
          },
          "serialNumber": {
            "type": "string",
            "description": "Serial number of the device recording the data"
          },
          "parentId": {
            "type": "string"
          },
          "picture": {
            "type": "array",
            "description": "Picture of the device/application",
            "items": {
              "type": "string",
              "description": "Picture of the device/application",
              "format": "byte"
            }
          },
          "properties": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Property"
            }
          },
          "systemMetaData": {
            "$ref": "#/components/schemas/SystemMetaDataOwner"
          }
        }
      },
      "SystemMetaDataOwner": {
        "required": [
          "hcPartyKeys",
          "privateKeyShamirPartitions"
        ],
        "type": "object",
        "properties": {
          "hcPartyKeys": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "privateKeyShamirPartitions": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "HealthcareProfessional": {
        "required": [
          "addresses",
          "languages",
          "names",
          "properties",
          "specialityCodes"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "the Id of the healthcare party. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "the revision of the healthcare party in the database, used for conflict management / optimistic locking."
          },
          "created": {
            "type": "integer",
            "description": "creation timestamp of the object.",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "description": "last modification timestamp of the object.",
            "format": "int64"
          },
          "deletionDate": {
            "type": "integer",
            "description": "the soft delete timestamp. When a healthcare professional is deleted, this is set to a non null value: the moment of the deletion",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "The full name of the healthcare party, used mainly when the healthcare party is an organization"
          },
          "lastName": {
            "type": "string",
            "description": "the lastname (surname) of the healthcare party. This is the official lastname that should be used for official administrative purposes."
          },
          "firstName": {
            "type": "string",
            "description": "the firstname (name) of the healthcare party."
          },
          "names": {
            "type": "array",
            "description": "the list of all names of the healthcare party, also containing the official full name information. Ordered by preference of use. First element is therefore the official name used for the healthcare party in the application",
            "items": {
              "$ref": "#/components/schemas/PersonName"
            }
          },
          "gender": {
            "type": "string",
            "description": "the gender of the healthcare party: male, female, indeterminate, changed, changedToMale, changedToFemale, unknown",
            "enum": [
              "male",
              "female",
              "indeterminate",
              "changed",
              "changedToMale",
              "changedToFemale",
              "unknown"
            ]
          },
          "civility": {
            "type": "string",
            "description": "Mr., Ms., Pr., Dr. ..."
          },
          "speciality": {
            "type": "string",
            "description": "Medical specialty of the healthcare party"
          },
          "parentId": {
            "type": "string",
            "description": "Id of parent of the user representing the healthcare party."
          },
          "addresses": {
            "type": "array",
            "description": "The list of addresses (with address type).",
            "items": {
              "$ref": "#/components/schemas/Address"
            }
          },
          "languages": {
            "type": "array",
            "description": "The list of languages spoken by the patient ordered by fluency (alpha-2 code http://www.loc.gov/standards/iso639-2/ascii_8bits.html).",
            "items": {
              "type": "string",
              "description": "The list of languages spoken by the patient ordered by fluency (alpha-2 code http://www.loc.gov/standards/iso639-2/ascii_8bits.html)."
            }
          },
          "picture": {
            "type": "string",
            "description": "A picture usually saved in JPEG format.",
            "format": "byte"
          },
          "specialityCodes": {
            "uniqueItems": true,
            "type": "array",
            "description": "Medical specialty of the healthcare party codified using FHIR or Kmehr codificaiton scheme",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "notes": {
            "type": "string",
            "description": "Text notes."
          },
          "properties": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Property"
            }
          },
          "systemMetaData": {
            "$ref": "#/components/schemas/SystemMetaDataOwner"
          }
        }
      },
      "HealthcareElement": {
        "required": [
          "codes",
          "identifiers",
          "labels"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the healthcare element. We encourage using either a v4 UUID or a HL7 Id."
          },
          "identifiers": {
            "type": "array",
            "description": "Typically used for business / client identifiers. An identifier should identify a data sample uniquely and unambiguously. However, iCure can't guarantee the uniqueness of those identifiers : This is something you need to take care of.",
            "items": {
              "$ref": "#/components/schemas/Identifier"
            }
          },
          "rev": {
            "type": "string",
            "description": "The revision of the healthcare element in the database, used for conflict management / optimistic locking."
          },
          "created": {
            "type": "integer",
            "description": "The timestamp (unix epoch in ms) of creation of this healthcare element in iCure system. Will be filled automatically if not provided.",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "description": "The timestamp (unix epoch in ms) of the latest modification of this healthcare element in iCure system. Will be filled automatically if not provided.",
            "format": "int64"
          },
          "author": {
            "type": "string",
            "description": "The id of the [User] that created this healthcare element. When creating the healthcare element, will be filled automatically by the current user id if not provided."
          },
          "responsible": {
            "type": "string",
            "description": "The id of the data owner that is responsible of this healthcare element. When creating the healthcare element, will be filled automatically by the current user data owner id ([HealthcareProfessional], [Patient] or [MedicalDevice]) if missing"
          },
          "medicalLocationId": {
            "type": "string"
          },
          "labels": {
            "uniqueItems": true,
            "type": "array",
            "description": "A label is an item from a codification system that qualifies a healthcare element as being member of a certain class, whatever the value it might have taken. If the label qualifies the content of a field, it means that whatever the content of the field, the label will always apply. LOINC is a codification system typically used for labels.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "codes": {
            "uniqueItems": true,
            "type": "array",
            "description": "A code is an item from a codification system that qualifies the content of this healthcare element. SNOMED-CT, ICPC-2 or ICD-10 codifications systems can be used for codes",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "endOfLife": {
            "type": "integer",
            "description": "Soft delete (unix epoch in ms) timestamp of the healthcare element",
            "format": "int64"
          },
          "deletionDate": {
            "type": "integer",
            "description": "the soft delete timestamp. When a healthcare element is deleted, this is set to a non null value: the moment of the deletion",
            "format": "int64"
          },
          "healthElementId": {
            "type": "string",
            "description": "The logical id of the healthcare element, used to link together different versions of the same healthcare element. We encourage using either a v4 UUID or a HL7 Id."
          },
          "valueDate": {
            "type": "integer",
            "description": "The date (unix epoch in ms) when the healthcare element is noted to have started and also closes on the same date",
            "format": "int64"
          },
          "openingDate": {
            "type": "integer",
            "description": "The date (unix epoch in ms) of the start of the healthcare element.",
            "format": "int64"
          },
          "closingDate": {
            "type": "integer",
            "description": "The date (unix epoch in ms) marking the end of the healthcare element.",
            "format": "int64"
          },
          "description": {
            "type": "string",
            "description": "Description of the healthcare element."
          },
          "note": {
            "type": "string",
            "description": "A text note (can be confidential, encrypted by default)."
          },
          "systemMetaData": {
            "$ref": "#/components/schemas/SystemMetaDataEncrypted"
          }
        }
      },
      "SystemMetaDataEncrypted": {
        "required": [
          "cryptedForeignKeys",
          "delegations",
          "encryptionKeys",
          "secretForeignKeys"
        ],
        "type": "object",
        "properties": {
          "secretForeignKeys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "cryptedForeignKeys": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          },
          "delegations": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          },
          "encryptionKeys": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Delegation"
              }
            }
          }
        }
      },
      "Document": {
        "required": [
          "otherUtis"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the document. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "The revision of the document in the database, used for conflict management / optimistic locking."
          },
          "created": {
            "type": "integer",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "format": "int64"
          },
          "author": {
            "type": "string"
          },
          "responsible": {
            "type": "string"
          },
          "medicalLocationId": {
            "type": "string"
          },
          "deletionDate": {
            "type": "integer",
            "format": "int64"
          },
          "objectStoreReference": {
            "type": "string",
            "description": "Reference in object store"
          },
          "mainUti": {
            "type": "string",
            "description": "The main Uniform Type Identifier of the document (https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE)"
          },
          "name": {
            "type": "string",
            "description": "Name of the document"
          },
          "version": {
            "type": "string",
            "description": "The document version"
          },
          "otherUtis": {
            "uniqueItems": true,
            "type": "array",
            "description": "Extra Uniform Type Identifiers",
            "items": {
              "type": "string",
              "description": "Extra Uniform Type Identifiers"
            }
          },
          "externalUuid": {
            "type": "string",
            "description": "A unique external id (from another external source)."
          },
          "size": {
            "type": "integer",
            "description": "Size of the document file",
            "format": "int64"
          },
          "hash": {
            "type": "string",
            "description": "Hashed version of the document"
          },
          "attachmentId": {
            "type": "string",
            "description": "Id of attachment to this document"
          }
        }
      },
      "Content": {
        "type": "object",
        "properties": {
          "stringValue": {
            "type": "string"
          },
          "numberValue": {
            "type": "number",
            "format": "double"
          },
          "booleanValue": {
            "type": "boolean"
          },
          "instantValue": {
            "type": "string",
            "format": "date-time"
          },
          "fuzzyDateValue": {
            "type": "integer",
            "description": "Value as date. The format could have a all three (day, month and year) or values on any of these three, whatever is known.",
            "format": "int64"
          },
          "binaryValue": {
            "type": "string",
            "format": "byte"
          },
          "documentId": {
            "type": "string",
            "description": "Linked document."
          },
          "measureValue": {
            "$ref": "#/components/schemas/Measure"
          },
          "timeSeries": {
            "$ref": "#/components/schemas/TimeSeries"
          },
          "compoundValue": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataSample"
            }
          },
          "ratio": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Measure"
            }
          },
          "range": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Measure"
            }
          }
        },
        "description": "Information contained in the data sample (Measure, number, ...). Content is localized, using ISO language code as key"
      },
      "DataSample": {
        "required": [
          "codes",
          "content",
          "identifiers",
          "labels",
          "qualifiedLinks"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the Data sample. We encourage using either a v4 UUID or a HL7 Id."
          },
          "transactionId": {
            "type": "string",
            "description": "The transactionId is used when a single data sample had to be split into parts for technical reasons. Several data samples with the same non null transaction id form one single data sample"
          },
          "identifiers": {
            "type": "array",
            "description": "Typically used for business / client identifiers. An identifier should identify a data sample uniquely and unambiguously. However, iCure can't guarantee the uniqueness of those identifiers : This is something you need to take care of.",
            "items": {
              "$ref": "#/components/schemas/Identifier"
            }
          },
          "batchId": {
            "type": "string",
            "description": "Id of the batch that embeds this data sample"
          },
          "healthElementsIds": {
            "uniqueItems": true,
            "type": "array",
            "description": "List of IDs of all healthcare elements for which the data sample is provided. Only used when the Data sample is emitted outside of its batch",
            "items": {
              "type": "string",
              "description": "List of IDs of all healthcare elements for which the data sample is provided. Only used when the Data sample is emitted outside of its batch"
            }
          },
          "canvasesIds": {
            "uniqueItems": true,
            "type": "array",
            "description": "List of Ids of all canvases linked to the Data sample. Only used when the Data sample is emitted outside of its batch.",
            "items": {
              "type": "string",
              "description": "List of Ids of all canvases linked to the Data sample. Only used when the Data sample is emitted outside of its batch."
            }
          },
          "index": {
            "type": "integer",
            "description": "Used for sorting data samples inside an upper object (A batch, a transaction, a FHIR bundle, ...)",
            "format": "int64"
          },
          "content": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Content"
            },
            "description": "Information contained in the data sample (Measure, number, ...). Content is localized, using ISO language code as key"
          },
          "valueDate": {
            "type": "integer",
            "description": "The date (YYYYMMDDhhmmss) when the Data sample is noted to have started and also closes on the same date",
            "format": "int64"
          },
          "openingDate": {
            "type": "integer",
            "description": "The date (YYYYMMDDhhmmss) of the start of the Data sample",
            "format": "int64"
          },
          "closingDate": {
            "type": "integer",
            "description": "The date (YYYYMMDDhhmmss) marking the end of the Data sample",
            "format": "int64"
          },
          "created": {
            "type": "integer",
            "description": "The timestamp (unix epoch in ms) of creation of this data sample in iCure system. Will be filled automatically if not provided.",
            "format": "int64"
          },
          "modified": {
            "type": "integer",
            "description": "The timestamp (unix epoch in ms) of the latest modification of this data sample in iCure system. Will be filled automatically if not provided.",
            "format": "int64"
          },
          "endOfLife": {
            "type": "integer",
            "description": "Soft delete (unix epoch in ms) timestamp of the data sample",
            "format": "int64"
          },
          "author": {
            "type": "string",
            "description": "The id of the [User] that created this data sample. When creating the data sample, will be filled automatically by the current user id if not provided."
          },
          "responsible": {
            "type": "string",
            "description": "The id of the data owner that is responsible of this data sample. When creating the data sample, will be filled automatically by the current user data owner id ([HealthcareProfessional], [Patient] or [MedicalDevice]) if missing"
          },
          "comment": {
            "type": "string",
            "description": "Text, comments on the Data sample provided"
          },
          "qualifiedLinks": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "string",
                "description": "Links towards related data samples (possibly in other batches)"
              },
              "description": "Links towards related data samples (possibly in other batches)"
            },
            "description": "Links towards related data samples (possibly in other batches)"
          },
          "codes": {
            "uniqueItems": true,
            "type": "array",
            "description": "A code is an item from a codification system that qualifies the content of this data sample. SNOMED-CT, ICPC-2 or ICD-10 codifications systems can be used for codes",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "labels": {
            "uniqueItems": true,
            "type": "array",
            "description": "A label is an item from a codification system that qualifies a data sample as being member of a certain class, whatever the value it might have taken. If the label qualifies the content of a field, it means that whatever the content of the field, the label will always apply. LOINC is a codification system typically used for labels.",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          }
        },
        "description": "A Data Sample represents a medical information, provided by a Data Owner concerning one specific [Patient], for a T moment. \n     Provided by a Data Owner means that the data sample may have been either provided by a [HealthcareProfessional] or a [Patient], either collected by a [MedicalDevice].   \n     Data Samples provided by the patient include subjective information, such as complaints, reason for visit, feelings, etc. or objective information \n     like bio-metric measures (blood pressure, temperature, heart beat, etc.), or physical exam description, diagnosis, prescription, integration of lab reports from another [HealthcareProfessional], action plan, etc.\n     Any action performed by the [HealthcareProfessional] (which is relevant for a [HealthcareElement] of a [Patient]) is considered as a [DataSample]. \n     The data samples can be linked to healthcare elements or other structuring elements of the medical record"
      },
      "Measure": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number",
            "format": "double"
          },
          "min": {
            "type": "number",
            "format": "double"
          },
          "max": {
            "type": "number",
            "format": "double"
          },
          "ref": {
            "type": "number",
            "format": "double"
          },
          "severity": {
            "type": "integer",
            "format": "int32"
          },
          "severityCode": {
            "type": "string"
          },
          "evolution": {
            "type": "integer",
            "format": "int32"
          },
          "unit": {
            "type": "string"
          },
          "unitCodes": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CodingReference"
            }
          },
          "comment": {
            "type": "string"
          },
          "comparator": {
            "type": "string"
          }
        }
      },
      "TimeSeries": {
        "required": [
          "fields",
          "max",
          "mean",
          "median",
          "min",
          "samples",
          "variance"
        ],
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "samples": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          },
          "min": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "max": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "mean": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "median": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "variance": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "description": "A high frequency time-series containing the ts in ms from the start (double) and the values"
      },
      "Coding": {
        "required": [
          "qualifiedLinks",
          "searchTerms"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "the Id of the coding. We encourage using either a v4 UUID or a HL7 Id."
          },
          "rev": {
            "type": "string",
            "description": "the revision of the coding in the database, used for conflict management / optimistic locking."
          },
          "type": {
            "type": "string"
          },
          "code": {
            "type": "string"
          },
          "version": {
            "type": "string",
            "description": "Must be lexicographically searchable"
          },
          "description": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "description": "Description (ex: {en: Rheumatic Aortic Stenosis, fr: Stnose rhumatode de l'Aorte})"
            },
            "description": "Description (ex: {en: Rheumatic Aortic Stenosis, fr: Stnose rhumatode de l'Aorte})"
          },
          "qualifiedLinks": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "description": "Links towards related codes",
              "items": {
                "type": "string",
                "description": "Links towards related codes"
              }
            },
            "description": "Links towards related codes"
          },
          "searchTerms": {
            "type": "object",
            "additionalProperties": {
              "uniqueItems": true,
              "type": "array",
              "description": "Extra search terms/ language",
              "items": {
                "type": "string",
                "description": "Extra search terms/ language"
              }
            },
            "description": "Extra search terms/ language"
          }
        }
      },
      "Filter": {
        "required": [
          "description"
        ],
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          }
        }
      },
      "PaginatedDocumentKeyAndIdPairObject": {
        "type": "object",
        "properties": {
          "startKey": {
            "type": "object"
          },
          "startKeyDocId": {
            "type": "string"
          }
        }
      },
      "PaginatedListUser": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/User"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListPatient": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Patient"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListMedicalDevice": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalDevice"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListHealthcareProfessional": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HealthcareProfessional"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListHealthcareElement": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HealthcareElement"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListDataSample": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataSample"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      },
      "PaginatedListCoding": {
        "required": [
          "pageSize",
          "rows",
          "totalSize"
        ],
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "format": "int32"
          },
          "totalSize": {
            "type": "integer",
            "format": "int32"
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Coding"
            }
          },
          "nextKeyPair": {
            "$ref": "#/components/schemas/PaginatedDocumentKeyAndIdPairObject"
          }
        }
      }
    }
  }
}
